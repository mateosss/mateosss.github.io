---
hidden: true
layout: post title: Fourth Update author: Mateo de Mayo date: 2021-03-29
18:00:00 -0300 abstract: > More steps were taken towards getting a better idea
of what visual-inertial SLAM open-source implementations are available and what
would it take to use one for tracking in Monado. ORB-SLAM3 and Kimera-VIO were
the main considered projects. Filtering information from different surveys and
continuing learning the SLAM jargon were a big part of this update as well.
brief: Considering open-source SLAM alternatives.
---

## Building Kimera

When building Kimera some problems arose. Kimera provides a
[dockerfile][kimera-dockerfile] for an easy installation in a container for
preview. In my case that worked well, however I preferred to install everything
in my system instead of a container. The repository provides an [installation
guide][kimera-install] however it is not very specific about which specific
snapshots the dependencies they were using and as such it broke in many of the
configurations I tried. After reading many github issues related to that I
figured it would be better to just stick to doing the same the dockerfile does,
and indeed that finally worked. *Note: the dockerfile uses Ubuntu 18.04 and
while I'm using a distro derived from it as well, to be sure I did an
`update-alternatives` to match every package that `build-essential` sets in
18.04.*

Here is a list of the HEAD of the dependencies I'm using for future reference.

[kimera-install]: https://example.com [kimera-dockerfile]: https://example.com

## C++ Refresher

While I quite like C++ and I've read some books about the language I've never
had the luck to work in a project that uses it for a decent amount of time. This
lack of practice shines when reading new code and makes the process a bit slower
than one would prefer.

For Kimera in particular, it seems to be mainly implemented in C++11. I had to
take some time to remember value categories and learn about how type deduction
of lvalue and rvalue for move semantics work with templates to understand why
`std::move` and `std::forward` exist (basically `static_cast<T&&>` with extra
steps). There is also `std::bind` which works the same as many `bind` functions
found in other languages; it partially applies arguments to functions. However,
it can be used to bind class methods to instances of those classes. To this end
it uses the concept of member functions which had gone under my radar along the
`.*` and `->*` operators; though one [should not use them][dont-star].

[dont-star]:
https://isocpp.org/wiki/faq/pointers-to-members#dotstar-vs-arrowstar

## Kimera Architecture

Kimera VIO is implemented as a pipeline (with some caveats outlined in `TODO`s)
which can run in parallel. It defines `PipelineModule`s which are configured via
YAML parameter files and compose the `Pipeline`, between those modules are
thread safe queues which one can `put` and `get` different amount of `Packet`s
(single input multiple output `SIMO` queues, `MIMO`, `MISO`, and so on). Here is
a diagram of this pipeline from the Kimera repo:

TODO: Put graph image
https://raw.githubusercontent.com/MIT-SPARK/Kimera-VIO/master/docs/media/kimeravio_chart.png

Each pipeline module is a wrapper to a class that implements the main algorithm
of that module. The wrapped classes are:

1. `EurocDataProvider`: Reads the EuRoC dataset from disk; it is currently the
   only supported dataset; it could be interesting to try to
   [extend][kimera-tumvi-issue] it with TUM VI. Its output is similar to:

```cpp
class StereoImuSyncPacket {
  StereoFrame stereo_frame; // Container of sanitized (undistorted) left and right images
  ImuStampS imu_stamps; //  IMU timestamps
  ImuAccGyrS imu_accgyrs; // IMU accelerometer and gyroscope samples
}
```

2. `StereoVisionFrontEnd` Takes the left and right camera images along the IMU
   accelerometer and gyroscope, detects and tracks the landmarks, and calculates the view
   pose relative to them. Its output is along the lines of:

```cpp
class FrontendOutput {
  const StereoMeasurements stereo_measurements; //
  // Breakdown:
  // StatusStereoMeasurements = (TrackerStatusSummary, SmartStereoMeasurements);
  // TrackerStatusSummary = {enum TrackingStatus mono/stereo, Pose3 relative_pose mono/stereo};
  // SmartStereoMeasurements = [(id, StereoPoint2)]

  const TrackingStatus tracker_status_ = VALID | LOW_DISPARITY | FEW_MATCHES | INVALID | DISABLED;

  const gtsam::Pose3 relative_pose_body_stereo_; // Viewer pose

  const StereoFrame stereo_frame_lkf_; // Similar to this module's input
  const ImuFrontEnd::PimPtr pim_; // IMU fusion (preintegration) data
  const ImuAccGyrS imu_acc_gyrs_; // accelerometer-gyroscope samples
  const cv::Mat feature_tracks_; // Display image with the landmark path for this frame
}
```

2. `VioBackEnd`: This class is responsible for *"adding up"* the visual-inertial states
   (the landmarks and viewer relative poses) on top of each other to build the graph
   of landmark predictions. It can also estimate the initial pose and velocity state based on IMU data.
   It produces an output similar to:

```cpp
class BackendOutput {
  const VioNavStateTimestamped W_State_Blkf_; // returned estimate of pose, velocity and IMU bias

  // Probabilistic state to be reused in next "spins" of the pipeline.
  // This portion of kimera uses a lot of gtsam.
  const gtsam::Values state_;
  const gtsam::Matrix state_covariance_lkf_; // lkf = last key frame
  const gtsam::NonlinearFactorGraph factor_graph_;

  Landmarks landmarks; // Tuples of (id, vector3)
}
```

3. Mesher?
4. Visualizer

[kimera-diagram]:
https://raw.githubusercontent.com/MIT-SPARK/Kimera-VIO/master/docs/media/kimeravio_chart.png
[kimera-tumvi-issue]: https://github.com/MIT-SPARK/Kimera-VIO/issues/122

Euroc/DataProvider -> Pipeline -> Data PipelineModule


read docs, salidas stdouts, entender params, que es evo y los jupyter de
Kimera-VIO-Evaluation rvalue & lvalue, std::move, std::forward, member function
pointers, ->* y .*, std::bind

C++ Concepts

Pipeline Modules
